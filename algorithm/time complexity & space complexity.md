# 공간복잡도&시간복잡도

## 공간복잡도 : 알고리즘 실행에 필요한 메모리 공간이 얼마나 많은지를 의미.

1. 문제의 크기가 얼마나 크냐와는 관계없이 알고리즘이 필요로하는 필수 고정 공간.
	ex. 알고리즘에서 사용되는 상수나 변수의 사이즈 등.

2. 문제의 크기에 따라 사이즈가 변하는 가변 공간. 
	ex. 동적 메모리 할당이나 재귀 스택 공간 등.
	=> 총 공간 요구 = 고정 공간 요구 + 가변 공간 요구 
		S(P) = c + Sp(n)


### 시간복잡도 순서
O(1) < O(logN) < O(n) < O(NlogN) < O(n^2) < O(2^n) < O(n!)



## 공간 복잡도 예시 문제

```
int factorial(int n){
	if(n > 1)
		return n*factorial(n-1);
	else
		return 1;
}
```
=> n이 1이하일 때까지 함수가 재귀호출 됨. 그러므로, 스택에는 n부터 1까지 모두 쌓이게 된다. 즉, O(n)


```
int factorial(int n){
	int i = 0;
	int fac = 1;
	for(i = 1; i <= n; i++){
		fac *= 1;
	}

	return fac;
}
```
=> n의 값에 상관없이 스택에는 n과 i 그리고 fac만 저장됨. 즉, 공간 복잡도는 O(1)


```
float abc(float a, float b, float c){
	return (a + b + b*c + (a + b - c) / (a + b ) + 4.0);
}
```
=> 공간 복잡도를 위해 살펴볼 것은 변수 a, b, c이다. 따라서, float형의 변수가 한 워드(word)를 차지한다고 가정하면, 공간복잡도는 '3워드'라고 생각할 수 있다. 그러나, 변수 a, b, c는 전달되는 인자로써 함수 abc내에서 해결하고자 하는 문제와는 무관하다고 볼 수 있으므로 공간복잡도는 0이다.

```
float Sum(float a[], int n){
	float s = 0.0;
	for(int i = 0; i <= n; i++){
		s += a[i];
	}

	return s;
}
```
=> 위의 프로그램에서 사용되는 변수는 a[], n, s, i이다. 그러나 [예제4.1]과는 다르게 변수 a[]는 합을 구하기 위하여 반복문 내에서 n개의 원소가 모두 참조되고 있음을 볼 수 있다. 또한, n은 for-문을 벗어나기 위한 한계값으로 사용된다. 따라서 a[]와 n은 알고리즘이 해결하고자 하는 문제와 밀접한 관련이 있다고 볼 수 있다. 그러므로 프로그램의 복잡도는 (a[]를 저장하기 위한 공간) + (변수 n, s, I를 위한 공간) = n + 3 이 된다.


```
float RSum(float a[], int n){
	if(n <= 0)
		return (0.0);

	else
		return (RSum(a, n-1) + a[n]);
}
```
=>   위의 프로그램은 순환기법(resursion)으로 작성된 것이다. 
위의 경우 살펴볼 변수는 a[], n이다. 
우선 변수 n은 if-문 내에서 순환의 한계값으로 사용되고 있음을 볼 수 있다. 
또한, 변수 a[]는 합을 구하기 위하여 사용되고 있으며 a[]의 원소 중에서 n번째의 원소만 필요로 한다. 
따라서 변수 a[]와 n이 모두 알고리즘과 밀접한 관계가 있으므로, 프로그램이 필요로 하는 공간은 (a[]의 n번째 원소를 의한 공간) + (n을 위한 공간) = 1 + 1 으로 볼 수 있다. 
그러나 위의 프로그램은 순환기법에 의해 작성되었음을 고려해야 한다. 
즉, 프로그램이 순환적으로 실행될 것을 고려해서 몇번의 순환후에 실행이 종료되는지(the depth of recursion)를 계산해야 하며, 또한 순환을 위해서 필요한 복귀 주소(return address)를 저장할 공간도 계산해야 한다. 
그러므로 프로그램의 공간 복잡도는 (depth of recursion)×(a[n], n, 복귀 주소를 위한 공간) = (n+1)×3 이 된다.

