# 좋은 코드를 만들기 위한 코딩 규칙


-----



>## 1. 명명규칙
*  ###  Lower camel case 표기법
> 보통 java의 메서드에 사용하는 규칙. 첫 글자는 소문자, 이어지는 각 단어의 첫 글자는 대문자로 표기하는 방법
```
> ex) getName()
```

>* ### 함수와 다른 규칙 사용
> JavaScript는 함수도 변수에 담을 수 있다. 그렇기 때문에 함수로 사용될 변수와 데이터를 담을 용도로 사용될 변수를 구분하기 위한 규칙을 사용하는 것이 좋음. 

>* ### 	 상수, 전역변수는 대문자 표기
>JavaScript(이하 JS로 표기)에서는 상수를 정의할 수 있는 방법이 없다. 

>* ### 	생성자 함수는 Upper camel case 표기법
> JS에서는 new연산자를 이용한 생성자 함수가 있다. 그러나, new연산자를 실수로 빼먹게 되도 일반 함수 호출로 자동하긴 하지만 this가 가리키는 곳이 달라지는 등, 기대한 것과 다르게 작동할 수 있어 오류를 찾기가 어렵다. 그러므로, 생성자 함수 목적으로 만들어진 함수는 함수 명을 구분 짓는 것이 좋다.
 ```
 > ex) SportsCar
 ```

>* ### private 메서드는  '_'로 단어 구분하기
	> JS에서도 클로저를 이용하여 private프로퍼티, 메서드를 구현하는 방법이 있지만 때에 따라서는 표기법을 달리하여 private메서드라는 것을 명시해주는 방법도 있다. 
	>이렇게 해도 메서드에 접근하는 것은 가능하지만, 이 메서드는 공개된 API가 아니기 때문에 직접적으로 호출하는 목적이 아니며 직접 호출 할 경우 정상적인 동작을 보장하지 않는 다는 것을 경고하는 것이다. 
  ```
 > ex) _privateMethod처럼 맨 앞에 '_'를 넣어 표기.
 ```



>## 2. 공백을 적절히 사용하기.

>> | 규칙| 예시 | 
| -------- | -------- | 
| for루프의 요소를 분리하는 세미콜론 다음 | ex) for (var i=0; i < 10; i += 1){...} |
| 배열의 원소들을 분리하는 쉼표 다음 | ex) var a = {1, 2, 3};|
| 익명 함수 표현식에서 function 다음 |  ex) function func(){...} , var func = function() {...}; |
| 연산자와 피연산자 양쪽 | ex) a = b + c; |

>## 3. 증감 연산자
	>>  ++, --와 같은 증감연산자를 사용하면 코드가 간결하게 보이고 직관적으로 보인다. 하지만, 이것이 한 구문에서 다른 연산자와 함께 사용되거나 여러 번 사용되는 것은 좋지 않다.


-----


# 가독성과 성능을 위해 권장되지 않는 안티 패턴

>## 1. switch case문에서 break 생략
>>코드를 만든 사람은 왜 이렇게 만들었는지 알지만, 유지보수 팀에서는 이게 실수로 빠진 것인지 의도적으로 뺀 것인지 알기 위해 관련된 로직을 다 뒤져가며 자세하게 살펴봐야 할 수도 있다. 만약, 의도적으로 case절에 break문을 빼야 한다면 왜 그렇게 했는지, 흐름이 어떻게 흘러가는 것인지 주석으로 자세하게 설명 해 놓는 것이 필요하다.

>## 2. 객체, 배열의 생성자 함수
>>JS에서 객체란 클래스로부터 생성하는 것이 아닌 그저 변형 가능한 해시에 불과하다. 때문에 굳이 길고 복잡한 new연산자를 사용하여 생성자 함수로 객체와 배열을 생성할 필요가 없다.
```
	ex) //안티패턴
		var arr = new Array(); 
		var obj = new Object();  
```

>> ```
	ex) //권장패턴
		var arr = [];
		var obj = {};
```
또한 몇 가지 문제점은 객체 생성자 함수 new Object()는 인자로 받을 수 있는데, 인자의 타입에 따라 동작을 다르게 한다. 때문에 런타입이 생성되는 동적인 값이 생성자에 인자로 전달될 경우 예기치 않은 결과가 반환될 수 있다. 

>>배열 생성자 함수 new Array()도 비슷한 문제로 인자를 받을 수 있는데 생성자에 숫자 하나를 전달할 경우 이 값은 배열의 첫 번째 원소가 되는 것이 아니고 배열의 길이를 지정한다. JS에서의 배열은 JAVA와 C처럼 진짜 배열이 아니기 때문에 대부분 이런 식으로 길이를 지정해 줄 필요가 없다. 또한, 이건 의외의 동작방식이긴 하지만, 인자에 정수가 아닌 소수를 가지는 수를 전달할 경우에는 배열의 길이로 유효한 값이 아니기 때문에 에러가 발생 하기까지 한다.

>## 3. 원시 데이터타입의 랩퍼 객체
>>JS에는 데이터타입의 랩퍼들이 있다. 이 랩퍼 객체들에는 toFixed(), substring(), length와 같은 유용한 프로퍼티, 메서드들이 있다. 하지만, JS에서는 원시 데이터타입 그대로 써도 랩퍼 객체의 메서들르 활용할 수 있다. 메서드를 호출하는 순간 내부적으로 원시 데이터 타입 값이 객체로 임시 변환되어 객체처럼 동작하게 된다.
```
ex)  //안티패턴
	var bool = new Boolean(true); 
	var str = new String("Hello"); 
	var no = new Number(1);
```

>>```
ex) //권장패턴
	var bool = true;
	var str = "Hello";
	var no = 1;
```
그러나, 원시 데이터 타입은 객체가 아니기 때문에 프로퍼티를 추가하여 확장할 수 없다. 그렇기 때문에 이런 특이한 상황이 아닌 일반적인 경우에는 생성자 함수를 사용 할 필요가 없다.

>## 4.  비트연산자
>>JS에는 Java와 같은 비트연산자들이 있다. Java에서 비트 연산자는 정수에 대해서 동작한다. 그런데 JS에는 정수형은 없고 단지 부동 소수점 숫자형만이 존재한다. 그래서 JS의 비트 연산자는 대상이 되는 숫자를 일단 정수형으로 변환한 다음 비트 연산을 수행하고 다시 원래의 타입으로 되돌린다. 대부분의 언어에서 비트 연산자는 하드웨어에 친근하고 속도도 매우 빠르지만, JS의 비트 연산자는 하드웨어와 전혀 친근하지 않고 속도가 느리다.

>## 5. for구문의 length
>>```
ex) //안티패턴 
	var domList = document.getElementsbyTagName("td");
	for (var i = 0; i < domList.length; i += 1) {...}
```


 >> ```
ex) //권장패턴
		var domList = document.getElementsbyTagName("td");
		var length = domList.length;
		for (var i = 0; i < length; i += 1) {...}
```


>>for구문 안에서는 보통 배열이나 HTML Collection 등 배열과 비슷한 객체를 탐색하며 처리한다. 
>>그런데 배열이라면 별로 상관이 없지만, 예제처럼 HTML Collection을 대상으로 for구문을 수행할 때 length를 캐싱하지 않고 바로 사용하는 것은 성능에 문제가 있다. 
>>캐싱을 할 경우 사파리에서 3에서 2배, IE7에서 190배에 이르기까지 모든 브라우저에서 속도가 향상된다. 이것은 HTML 페이지에 대한 실시간 질의라는 점에서 문제가 된다. 즉, HTML Collection의 length 속성에 접근할 때마다 실제 DOM에 요청하는 것과 같으며,  DOM접근은 일반적으로 비용이 큰 작업이다.

	


-----


# 오류를 발생 시킬 수 있는 안티 패턴

>## 1. 항등연산자에서의 암묵적 타입캐스팅
>> JS는 변수를 비교할 때 암묵적으로 타입캐스팅을 실행한다. 
	때문에 의도하지 않았던 결과를 반환하기도 하는데 이로 인한 혼동을 막기 위해서, 동등 비교 연산자로 항상 값과 타입까지 체크하여 비교하는 **===와 !==(완전항등연산자)를 사용**하는 것이 좋다. 
	
	
>>```
ex)  //안티패턴 예시
		"" == "0"                    // false            
		0 == ""                      // true
		0 == "0"                   // true
```

>>```
ex)  //권장 예시
		"" === "0"                 //false
		 0 === ""	              //false
		 0 === "0"               //false
```

>>==으로 충분할 때에도 ===를 쓰는 것은 불필요한 일이라고 생각하는 사람들도 있다. 그러나, 완전항등연산자를 사용함으로써 코드의 일관성을 지키고 다른 사람이 코드를 읽으며 ==가 의도된 것인지 아니면 누락된 것인지 고민 하는 것을 없애준다.

>## 2. 암묵적 전역변수
>>JS의 가장 나쁜 점 중 하나는 언어가 전역변수에 기반하고 있다는 것이다. 전역변수는 프로그램이 점점 커짐에 따라 다루기가 까다롭고 복잡해지며, 프로그램의 모든 부분에서 변경될 수 있기 때문에 오류를 유발시킨다. 또한 JS는 전역변수가 필요한 경우에만 사용할 수 없기 때문에 문제가 된다.
```
ex) //안티패턴 예시
		function func() {
			var a = b = 0;
		}
```

>> ```
ex) //권장 예시
		function func() {
			var a, b;
			a = b = 0;
		}
```

>>JS는 유효범위 안에서 var를 사용하여 변수를 생성하면 지역변수로 생성되고, 전역범위에 선언을 하거나 var를 사용하지 않고 선언하거나 선언되지 않는 변수를 사용하게 되면 전역변수로 생성한다. 
>>그렇기 때문에 변수를 선언하지 않고 사용하거나 var를 빼먹는 것을 주의해야 한다. 

>## 3. 부동소수점 연산
>> JS에서 소수점 숫자의 계산을 할 때는 주의 깊게 사용해야 한다. 이진 부동 소수점 연산의 문제인데 소수 부분을 제대로 처리하지 못한다.

>>```
>>ex)  var booleanA, bolleanB;
		booleanA = (0.1 + 0.2 === 0.3);						           // 0.1 + 0.2는 0.30000000000000004, false
		booleanB = ((0.1 * 10 + 0.2 * 10) / 10 === 0.3);       //true
```

	
>>위의 예제와 같이 0.1과 0.2를 더하면 0.3이 아닌 값이 나온다. 이를 정확하게 계산하기 위해서는 소수점 숫자를 정수 형태가 되도록 값을 곱한 후 계산 한 뒤에 다시 나눈다.

>## 4. 함수선언문
>>JS에서 함수를 정의하는 방법은 크게 함수 선언문과 함수 표현식이 있다.


>> ```
 ex) // 안티패턴
		// 전역함수
	function hello() {  
			console.log("Hello");
	}
	function goodBye() {  
			console.log("Good Bye");
	}
	function hoistFunc() {  
			console.log(typeof hello);    // “function”
			console.log(typeof boodBye);  // “undefined”
			hello();   // “local Hello”
			goodBye(); // TypeError: undefined is not  a function
			// 함수 선언문
			function hello() {
					console.log("local Hello");
			}
			// 함수 표현식
			var goodBye = function () {
					console.log("local Good Bye");
			}
	}
	hoistFunc();  
```

>>위의 예제에서 hoistFunc()내의 goodBye가 함수 표현식이고 나머지는 모두 함수 선언문이다.
	이 둘에는 호이스팅(Hoisting, 끌어올려짐)에서 차이점이 있는데 JS에서 함수는 호이스팅 대상이다.
	그렇기 때문에 함수 선언문으로 작성된 hoistFunc()함수 내 hello()지역 함수는 hoistFunc()함수가 실행될 때 함수의 유효범위 맨 위로 올라간다. 반면 함수 표현식으로 작성 된 goodBye는 변수 선언만 호이스팅되고 변수에 함수를 대입하는 함수 선언부는 코드상의 위치 그대로 있다.

>>실제로 코드가 실행되는 순서는 아래와 같다. 전역함수 부분은 생략하였다.
	
>>```
ex) 
// 전역함수
...
function hoistFunc() {  
		// 
		function hello() {
				console.log("local Hello");
		}
		var goodBye;
		console.log(typeof hello);    // "function"
		console.log(typeof goodBye);  // "undefined"
		hello();   // "local Hello"
		goodBye(); // TypeError: undefined is not a function
		goodBye = function () {
				console.log("local Good Bye");
		};
}
hoistFunc();  
```


>>그렇다면, 함수가 호이스팅 되고, 호이스팅 되지 않는 것에는 근본적으로 어떤 차이점이 발생할까? 
>>우리는 대다수의 프로그래밍에서 함수를 먼저 선언하고 호출한다는 것에 익숙해져 있다. 하지만 함수 선언문으로 정의된 함수는 우리가 함수 정의를 위치시키는 곳에서 동작하지 않고 우리의 생각과는 다른 순서로 동작할 수 있다.
	hoistFunc()함수 내에서 hello()함수를 선언한 후 호출한 다음에 함수의 내용을 바꿨지만 함수명은 같은 함수를 재정의하고 다른 목적으로 호출 했다고 생각해 보자. 이것은 우리의 의도와는 다른게 두 개의 서로 다른 함수 정의가 모두 호이스팅 되어서 두 번의 함수 호출 모두 두 번째 hello()가 동작하게 될 것이다. 

>>또한 함수 표현식은 함수 값을 가진 변수라는 것을 명확히 나타낸다. 이는 JS라는 언어의 특징인 함수도 값이라는 것을 잘 나타내고 있다.

>## 5. for, for-in 구문
>> JS에는 일반적인 for문 말고도 for-in문이 있다. JAVA의 for each문과 비슷한 것으로 객체에 있는 모든 속성을 인덱스 없이 탐색할 때 사용된다. 
>> 하지만 for문과 다른게 for-in문은 프로토타입에 있는 속성까지도 포함되고 순서가 보장되지 않는다. 그렇기 때문에 배열에서는 for문을 사용하고 객체에서만 for-in문을 사용하는 것이 좋다. 또한 for-in문을 사용할 때는 원하지 않는 프로토타입의 속성을 필터링하기 위하여 hasOwnProperty()메서드를 사용해야 한다. 

>## 6. 중괄호
>>```
ex) //안티패턴
		if (car)  
	    car.start();
	    car.end();
```
	    if (car) {  
		    car.start();
		}
		car.end();  


>>if문 등의 중괄호를 사용하는 구문에서 내용이 단 한 줄이라도 중괄호를 생략하지 않는 것이 좋다. 
>>이것은 비단 JS에서만이 아니라 모든 언어에서 마찬가지일 것이다. 위의 예제에서 car.end()부분이 없다고 하더라도 나중에 다른 사람에 의해서 추가될 수도 있고 추가하는 사람이 car.start()에서 한 라인을 띠우고 car.end()를 넣는다는 보장은 없다. 이렇게 if문의 내용과 바깥영역의 라인이 붙어있으면 마치 둘 다 if문 안에 있는 것으로 보일 수 있다.

>>또 다른 문제로 중괄호의 위치는 버그를 발생시킬 수 있다. 
>>
	ex) // 안티패턴
	return            // return undefined  
	{
	    lastName : "홍",
	    firstName : "길동"
	};

>>```
return {  
    lastName : "홍",
	firstName : "길동"
};
```

>>위의 예제는 객체를 리턴 하고 있고 코드만 봐서는 별 문제가 없어 보일 수 있다. 하지만, JS의 특성 때문에 문제가 발생한다. JS는 자동으로 세미콜론을 삽입하여 잘못된 프로그램을 교정하려는 메커니즘이 있다. 세미콜론을 쓰지 않고 행을 종료하면 알아서 세미콜론을 추가해 준다는 것이다. 그래서 가끔 세미콜론을 빼먹어도 문제없이 작동하는 것을 봤을 것이다.

>>하지만, 이러한 점 때문에 예상치 못한 결과가 발생하기도 한다. 코드 작성자가 원했던 것은 lastName과 firstName을 프로퍼티로 가지고 있는 객체를 리턴 하는 것이었지만, 중괄호의 위치 때문에 return뒤에 세미콜론이 자동 삽입될 수 있다. 


[참고본문](http://www.nextree.co.kr/p6362/ )