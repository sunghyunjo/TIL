# Script의 Async와 Defer속성

웹브라우저는 html을 렌더링하는 과정에서 css나, js를 만나면 동기적으로 처리한다. 다시 말하자면, 해당 내용을 해석하고 실행하기 전에는 뒤의 내용을 처리하지 않는다는 것이다. 이는 화면 렌더링 속도에 큰 영향을 줄 수 있다. 

css는 화면을 렌더링하는 데에 필요한 정보를 담고 있기 때문에 해당 내용을 출력하기 전에 해석되는 것이 당연히 유리하다. 이는 화면이 여러 번 렌더링 되는 현상도 줄일 수 있다. 

javascript의 경우는 대부분 화면 출력보다는 기능적인 처리에 관련된 경우가 많다. 웹앱 등의 경우 출력과 직접적인 관련이 있을 수도 있으니 이 또한 기본적인 화면이 출력된 이후에 처리되는 것이 웹 페이지를 빠르게 렌더링하는 데에 유리하기 때문에 처리를 지연시키는 편이 좋다.

```
<html>
		<head>
			<script>
			console.log("script Tag");
			</script>
		</head>
		<body>
		This is body
			<script src="www.example.com/js/script.js"></script>
		</body>
</html>
```
위와 같이 script태그는 어디든 배치 될 수 있으며, 위에서 아래로 HTML문서를 읽는 브라우저들의 특성 상, head태그에 외부 스크립트가 배치될 경우에는 페이지 렌더링이 시작되기 전에 head에 배치된 스크립트가 다운로드되고,  파싱되고 실행되게 된다. 만약 상당히 큰 스크립트 파일을 head에 배치하게 될 경우, body렌더링이 시작되기 전에 스크립트를 실행하는 데에 많은 시간을 할애할 수 있다. 하지만 body태그의 마지막에 스크립트 태그를 배치하게 되면, html페이지의 body내용이 다 렌더링 된 후에 스크립트를 다운받기 시작하니 사용자 입장에서 보이는 페이지 로딩시간을 줄일 수 있다.

이러한 이유로 인해 대부분 css는 `<head> `영역에, js는 `</body> `바로 앞에 선언하는 것을 추천한다. 이 방식은 오래된 브라우저에서도 동일한 효과를 얻는 좋은 방법이 될 수 있다. 하지만, 이 방법 외에도,  script에는 **async**와 defer속성을 사용하는 방법이 있다. 


-----


## 일반적인 실행 과정 
async와 defer의 동작에 대해 알아보기 전, 기본적인 script의 실행과정에 대해 알아보자. 기본적으로 script는 인라인 코드의 경우 즉시 해석되고 실행될 수 있지만 그렇지 않은 경우는 해당 파일을 가져올 때까지 HTML문서의 구문 분석을 중단시킨다.

![일반적인 실행 과정](https://blog.asamaru.net/res/img/post/2017/05/script-async-defer-1.png)

위의 그림처럼 스크립트를 가져와서 실행하기 위해서는 HTML구문 분석이 일시 중단되기 때문에  HTML이 화면에 출력되는 시간이 길어진다.


-----


## async속성이 추가된 경우

```
<script async src="script.js">
```
async속성은 브라우저에 스크립트 파일이 비동기적으로 실행될 수 있음을 나타내기 위해서 사용되어진다. HTML구문 분석기는 스크립트 태그에 도달한 지점에서 스크립트를 가져오고 실행하기 위해서 일시 중지할 필요가 없어진다. 그러므로, HTML구문 분석과 병행하여 스크립트를 가져온 후, 스크립트가 준비 될 대마다 즉시 실행이 가능해진다. 

그러므로, 실행의 순서가 다운로드 완료 시점에 따라 결정되므로 실행 순서가 중요한 스크립트들에 async속성을 사용하는 것은 유의해야 한다. 

![async속성이 추가된 경우](https://blog.asamaru.net/res/img/post/2017/05/script-async-defer-2.png)

이 속성은 외부에 위치한 스크립트 파일에서만 사용할 수 있다. 외부 스크립트에 이 속성이 있으면 HTML문서가 여전히 구문 분석되는 동안 파일을 다운로드 할 수 있고, 다운로드가 완료되면 스크립트가 실행될 수 있도록 구문 분석이 일시 중지된다.


async속성을 가진 스크립트 태그 같은 경우에는 HTML파싱과 동시에 스크립트 다운로드가 진행된다. 그리고 스크립트 다운로드가 완료되는 순간 HTML파싱을 잠시 멈추고 스크립트를 실행한다. 이러한 특성 때문에 순서대로 다운로드가 시작된 스크립트라도 순서대로 실행되지 않는다. 아래 예제를 통해 알 수 있다. 
```
<html>
	<head>
			<script async src="script1.js"></script>
			<script async src="script2.js"></script>
	</head>
	<body>
		This is Body
	</body>
</html>
```
```
//script1
console.log("script1");
//script2
console.log("script2");
```
```
// RESULT
	script2
	script1
```
이러한 이유로 인해 DOM(Document Object Model)을 수정하는 스크립트 같은 경우는 async속성을 사용하지 않는게 좋다.

-----

# defer속성이 추가된 경우

```
<script defer src="script.js">
```
defer속성은 HTML파싱이 완전히 완료되면 스크립트 파일을 실행하도록 브라우저에 지시한다.

![defer속성이 추가된 경우](https://blog.asamaru.net/res/img/post/2017/05/script-async-defer-3.png)
비동기적으로 로드된 스크립트와 마찬가지로, HTML구문 분석이 실행되는 동안 파일을 다운로드 할 수 있다. 그러나, HTML구문 분석이 완료되기 전에 스크립트 다운로드가 완료되더라도 구문 분석이 완료될 때까지 스크립트는 실행되지 않는다. 또한, async와 다르게 호출된 순서대로 실행된다.

아래의 예제를 보자.
```
<html>
	<head>
			<script defer src="script1.js"></script>
			<script defer src="script2.js"></script>
	</head>
	<body>
		This is Body
	</body>
</html>
```
```
//script1
console.log("script1");
//script2
console.log("script2");
```
```
// RESULT
	script1
	script2
```
스크립트 태그가 헤드 내에 위치해 있으나 HTML파싱을 멈추지 않고 바로 다운로드가 진행된다. 그리고 `</html>` 엔드태그를 읽어야 스크립트를 실행하게 된다. 그리고 async태그와 달리 스크립트는  HTML문서 내에 위치한 대로 실행 된다. 그러니 위의 예제에서는 html문서 파싱이 완료된 후에 script1, script2가 순서대로 실행된다. 

-----
# 적절한 사용처
일반적으로 스크립트 실행과 async, defer실행을 결정하기 위해서는 몇 가지 확인해야 할 사항이 있다.

1. ### **`<script>`요소의 위치**
script요소가 문서의 맨 끝에 있지 않다면, script의 비동기 및 지연 실행이 더 중요하다. HTML문서는 첫 번째 여는 `<html>`요소부터 닫히는 순서로 파싱된다. 외부 JavaScript파일이 닫는 `</body>`요소의 바로 앞에 있다면, async또는 defer속성을 사용하는 것이 큰 의미가 없다. (HTML파싱이 그 시점까지 문서의 대다수를 완성 했기 때문에 지연에 큰 의미가 없다는 것.)

1. ### **스크립트 자체가 포함 여부**
다른 파일들에 종속적이지 않거나 종속성 자체가 없는 스크립트 파일들의 경우 async속성이 특히 유용하다. 파일이 어느 지점에서 실행되는지 정확히 알 필요가 없기 대문에 비동기 로드가 가장 적합하다.

1. ### **스크립트의 크기와 종속성 여부**
스크립트가 비교적 작고 다른 파일에 의존하는 경우 인라인으로 정의하는 것이 더 유용할 수 있다. 인라인을 사용하면 HTML문서의 파싱이 차단되지만 크기가 작으면 큰 문제가 되지 않는다. 또한 다른 파일에 의존하는 경우 차단이 필요할 수 있다.
