# Frame vs Page
## 프레임(Frame)
-	물리 메모리를 사용하는 최소 크기 단위

## 페이지(Page)
-	가상 메모리를 사용하는 최소 크기 단위
  
### 가상 메모리
-	각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식을 말한다. 
-	RAM의 부족한 용량을 보완하는 데에 주로 쓰인다.
-	가동되고 있는 프로세스들의 페이지 중 덜 중요한 것들을 하드 디스크의 공간에 옮겨 놓는다. 그리고 프로세스가 동작하는 도중, 메모리에 필요한 페이지가 없으면 하드디스크를 찾아 해당 데이터를 가져온다. 

# 페이징
페이지 폴트가 발생하면, 해당 페이지를 가상 메모리에서 찾아야 한다. 이것을 해결하는 과정을 페이징이라고 한다.

1. 먼저 CPU는 물리 메모리를 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘 후, 운영체제는 페이지 테이블에서 가상 메모리에 페이지가 존재하는 지 확인하고, 없으면 프로세스를 중단한다.
3. 페이지폴트이면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾느다.
4. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
5. 중단된 CPU동작을 다시 시작한다.

## 페이지 폴트
- 가상 메모리의 내용을 물리 메모리에 로드하는 과정에서 무작위로 위치 및 크기를 설정하여 로드하면 메모리 공간에 빈공간이 발생한다. 
- 이를 최소화 하기 위해 프레임과 페이지를 도입하였고, 프레임과 페이지의 크기는 보통 같으며, 페이지는 프로세스의 구성요소라고 볼 수 있다.
- 운영체제의 스와퍼는 물리 메모리에 동작하고 있는 모든 프로세스를 로드하지 않는다.
- 게다가 운영체제의 페이저는 프로세스의 모든 페이지를 물리메모리에 로드하지 않는다. 
(물리메모리를 효율적으로 사용하기 위해서) 그러므로, 프로그램의 페이지가 물리 메모리에 부재할 수 있는데, 이것을 페이지 폴트 라고 한다.

## 페이지 교체 알고리즘
-	만일, 빈 프레임이 없다면 희생 프레임을 골라서 가상 메모리에 저장 후 필요한 페이지를 물리 메모리에 로드하는 방법.

### FIFO(First In First Out) 
가장 먼저 물리 메모리에 적재된 페이지를 선택하는 방식

### LRU(Least Recent Used) 
가장 오랫동안 사용되지 않았던 페이지를 선택하는 방식
-	LRU알고리즘을 구현하기 위해서는 해당 프레임이 언제 사용되었는지를 알아야 한다. 
1. Counter를 이용하여 매번 페이지 호출이 일어날 때마다 시간을 체크하여 time이 가장 오래된 것을 선택하는 방법. 그러나, 페이지 테이블이 변경될 때마다 해당 페이지의 시간도 같이 변경 되어야 하는 단점이 있다.
2. Stack을 이용하는 방법. 여기서 stack은 일반적인 스택의 기능에 doubly linked list가 추가된 것이어야 함. 매번 페이지가 호출될 때마다 그 페이지 번호를 스택에 저장하는 방식. 페이지가 호출될 때 스택에 이미 그 페이지가 있을 경우에는 해당 페이지를 스택에서 pop()시키고, 새로 push()한다. 스택에 존재하지 않을 경우에는 그냥 push()한다.
> 왜 스택에 doubly linked list가 추가되야 하는가?
> 일반적인 스택에거 pop()이 마지막에 들어간 것을 제거하는 것에 비해, doubly linked list가 추가된 스택은 pop()을 하면 마지막의 것이 아닌 새로 들어갈 것과 같은 이름의 element가 제거된다. 이렇게 할 경우 일반적인 stack보다 구현에 있어 좀 더 비용면에서 불리할 수 있지만, 프레임이 변경되야 할 때 counter방식처럼 search할 필요가 없이 그냥 tail을 선택하면 되기 때문에 좋은 방법이 될 수 있다. 
