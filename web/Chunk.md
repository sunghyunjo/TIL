# Chunk
- 데이터를 분산해서 관리하는 방법
- 레코드 : 데이터의 필드들을 묶어 놓은 대표 키 
- 어떤 파일 형태인지 알기 위해서는 각 파일 형태에 해당하는 청크를 찾는다. ex) RIFF = 멀티미디어 파일.
	=> 'RIFF'라는 문자열만 있다면 멀티미디어 파일로 인식하는 것이다.
- 즉, 청크는 어떠한 정보 덩어리를 나누어 놓고서, 그 덩어리에 대한 정보를 찾기 위한 색인 수단의 편리를 제공한 것이다.

# Chunk Response
- 전체 페이지를 가공하지 않고 즉, 서버측에서 html을 전부 생성한 후에 클라이언트에게 보내는 것이 아니라 html을 덩어리(chunk)단위로 쪼개서 보낼 수 있다. 
- 브라우저에게 전체 컨텐츠 크기가 얼마나 큰지 알려주지 않아도 된다.
따라서, 동적인 크기의 컨텐츠에 적합하다.
- 스트리밍에도 좋고.
- 이러한 방식의 의미는 Chunked transfer encoding을 사용해야 한다.

# Chunked transfer encoding은?
- HTTP 1.1 데이터 전송 매커니즘 중 하나. 
- 덩어리(Chunk)의 나열로 데이터를 전송한다는 것.
- HTTP헤더의 Contents-Length대신 Transfer-Encoding을 사용.
- Content-Length 속성을 사용하지 않기 때문에, Receiver에 대한 응답을 전송하기 전에 Sender는 컨텐츠의 길이를 알 필요가 없다. Sender는 그 컨텐츠의 크기 전체를 알기 전에 동적으로 생성한 콘텐츠를 전송할 수 있다.
	=> Ex. 기존에는 서버에서 동영상을 인코딩을 다 하고 난 후, 동영상의 사이즈를 파악한 후에 전송할 수 있었다면, Chunked transfer encoding은 전체 크기를 알 필요가 없고 조각조각 보내기 때문에 가공을 하는 중간중간에도 계속 데이터를 전송할 수 있다는 의미.


# Chunked Data를 사용하는 상황
- 긴 처리시간이 필요한 사이트에서는 서버가 response를 만드는 동안 사용자는 어떠한 화면도 볼 수 없다. 
- 그러나, Chunked Response를 쓴다면 컨텐츠의 특정 부분을 생성할 수 있고, 클라이언트에게 미리 던져줄 수 있다. HTML <head>태그 안에 script와 stylesheet들이 있다면 사용자 브라우저에 <html>태그 안의 정보만 미리 던져줄 수 있다. 그 동안 서버는 DB에서 데이터를 가져오든 뭘하든 나머지 부분을 생성할 수 있고, 브라우저는 head의 자원들을 해석하고 있을 수 있다. 즉, 병렬적으로 둘 다 일을 할 수 있다.
- 심지어, 사용자가 컨텐츠의 일부만 본다거나 할때처럼 이런 처리들이 적합하지 않는다고 해도, 사용자는 더 나은 성능인 듯한 느낌을 받을 수 있다.

# 대용량 데이터 집합을 웹 서비스 메세지에서 전송할 때 발생하는 두 가지 문제
1. serialization 엔진의 버퍼링으로 인한 대용량 작업 집합(메모리)
2. Base64 인코딩 후 33퍼센트 확장으로 인한 과도한 대역폭 소비
