## Canvas
우리가 알다 싶이 Canvas는 HTML5에 추가 되었고, JS에서만 동작하도록 되어있다.

- 그래프나 여러 도형을 그리는데 유용하고, 복잡한 사진 합성에 사용되곤 한다. 
- 라이브영상과 최상의 애니메이션을 만들어 낼 수 있다.

### Example
#### HTML
```html
<canvas id="canvas"></canvas>
```

#### JavaScript
```js
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

ctx.fillStyle = 'green';
ctx.fillRect(10, 10, 100, 100);
```

위의 코드를 실행하면 쉽게 초록색 박스가 나올 것이다.

Canvas는 스프라이트 같은 게임이나 인터렉티브한 래스터 그래픽을 렌더링하는데에 적합하고, 이미지를 편집하거나 픽셀 단위로 조작이 필요한 경우 유용하다.

## SVG
- SVG(Scalable Vector Graphics)는 웹용 그래픽을 그리기 위한 도구로 사용된다.
- SVG요소는 그 자체의 뷰포트와 좌표 시스템을 가지고 있다.
- SVG는 아래와 같은 특정 요소에만 허용된다. 

```
<a>, <altGlyphDef>, <clipPath>, <color-profile>, <cursor>, <filter>,
<font>, <font-face>, <foreignObject>, <image>, <marker>, <mask>, 
<pattern>, <script>, <style>, <switch>, <text>, <view> 

<animate>, <animateColor>, <animateMotion>, <animateTransform>, 
<discard>, <mpath>, <set>, <circle>, <ellipse>, <line>, <polygon>, <polyline>, <rect>
```

- SVG는 해상도와 독립적이기 때문에, 각 요소에 액세스 할 수 있어야 하는 플랫폼 간 UI/UX 구성 요소나 애니메이션 및 응용 프로그램을 렌더링하는데에 이상적이다.
- SVG는 다른 멀티미디어 요소들이나 오디오 태그, 비디오에도 높은 퀄리티를 제공하기 때문에 브라우저에서 가장 강력하다.
- viewBox 특성은 SVG 그림의 좌표가 상대적인 노논리적 좌표계를 설정한다. 이 경우, 우리의 그림은 100 x 100의 뷰포트에 배치된다.

### Example

```html
<svg id="SearchIcon" viewBox="0 0 3000.29 592.05" xmlns="http://www.w3.org/2000/svg">   
<path 
d="M2409,211.5c0,116.25,94.24,210.5,210.5,210.5a209.45,209.45,0,0,0,115.68-34.66c.55.62,1,1.31,1.55,1.9L2848,500.47A42.79,42.79,0,1,0,2908.47,440L2797.24,328.73c-.59-.59-1.28-1-1.9-1.55A209.46,209.46,0,0,0,2830,211.5C2830,95.24,2735.75,1,2619.5,1S2409,95.24,2409,211.5M2482,211.5A137.53,137.53,0,1,1,2619.5,349,137.53,137.53,0,0,1,2482,211.5">
</path>   
  </svg>
```
위의 예제는 [이것](https://image.flaticon.com/icons/svg/49/49116.svg)처럼 나오는 검색 아이콘이다.

그러나, 이는 이미지가 아니라 SVG요소이다. 이를 사용하면 좀 더 인터렉티브한 UI를 [이처럼](https://codepen.io/arcticben/pen/xqBbqK)만들 수 있다.

하지만, 이는 몇 가지 단점이 있다. 

- 첫째, 객체에 많은 수의 요소들이 있는 경우 파일 크기가 매우 빠르게 커질 수 있다. 
- 둘째, 위에서 볼 수 있듯이 그래픽 객체를 읽는 것은 불가능하다.

## Canvas vs SVG

### 유연성?
알다 싶이, SVG는 이미지 파일이나 코드를 사용하는 것보다 시각적으로 더 정교한 이미지를 제공한다.

#### For Example :

```html
<img src="image.svg" alt="image">
.element {
background-image: url(/images/image.svg);
}
```
 
```html
<svg id="SearchIcon" viewBox="0 0 3000.29 592.05" xmlns="http://www.w3.org/2000/svg">    
	<path d="M2409,211.5c0,116.25,94.24,210.5,210.5,210.5a209.45,209.45,0,0,0,115.68-34.66c.55.62,1,1.31,1.55,1.9L2848,500.47A42.79,42.79,0,1,0,2908.47,440L2797.24,328.73c-.59-.59-1.28-1-1.9-1.55A209.46,209.46,0,0,0,2830,211.5C2830,95.24,2735.75,1,2619.5,1S2409,95.24,2409,211.5M2482,211.5A137.53,137.53,0,1,1,2619.5,349,137.53,137.53,0,0,1,2482,211.5"></path>
</svg>
```

SVG는 크기에 상관 없이 브라우저/창 크기를 조절해도 퀄리티는 동일하게 유지된다. SVG는 크기를 증가시키는 것만으로도 유연하게 변경된다.

### 로딩 시간
SVG나 Canvas 중 어떤 것을 사용하는지의 여부는 주로 특정 응용 프로그램에 달려 있음을 알 수 있다.

매번 새로운 요소가 다시 그려지는 그래픽에 강화된 게임은 Canvas가 적합하다. 반면에, 많은 지역을 그려야 하는 지도 뷰와 같은 경우는 SVG가 적합하다.

### 주요 차이점
#### Canvas
- 해상도 의존적
- 이벤트 핸들러를 제공하지 않는다.
- 텍스트 렌더링 성능이 좋지 않다.
- 이미지나 .png 나 .jpg 결과를 저장할 수 있다.
- 그래픽 친화적인 게임에 적합하다.

#### SVG
- 해상도 독립적
- 이벤트 핸들러를 제공한다.
- 큰 범위를 랜더링 해야하는 어플리케이션에 최적
- 복잡하다면, 늦은 속도로 렌더링 된다. 
- 게임 어플리케이션에 잘 맞지 않는다.

## 결론
- SVG는 적은 아이템이 들어있는 어플리케이션이나 앱에 적합하다.
- Canvas는 세밀한 조작과 수 천개의 객체들이 있을 때 적합하지만, 많은 코드가 필요할 수 있다.

[참고](https://medium.com/@benisinca/svg-vs-canvas-92938aff799a)
